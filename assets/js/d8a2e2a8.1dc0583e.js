"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[667],{1716:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>r});var n=s(4848),i=s(8453);const l={id:"cell-model",title:"Cell Model",sidebar_position:2},a=void 0,o={id:"concepts/cell-model",title:"Cell Model",description:"Nervos CKB inherits Bitcoin\u2019s architecture and creates the Cell model, a generalized UTXO model as state storage.",source:"@site/docs/concepts/cell-model.md",sourceDirName:"concepts",slug:"/concepts/cell-model",permalink:"/docs/concepts/cell-model",draft:!1,unlisted:!1,editUrl:"https://github.com/nervosnetwork/docs-new/tree/develop-v2/website/docs/concepts/cell-model.md",tags:[],version:"current",lastUpdatedAt:1712118446,formattedLastUpdatedAt:"Apr 3, 2024",sidebarPosition:2,frontMatter:{id:"cell-model",title:"Cell Model",sidebar_position:2},sidebar:"tutorial",previous:{title:"Nervos Blockchain",permalink:"/docs/concepts/nervos-blockchain"},next:{title:"CKB-VM",permalink:"/docs/concepts/ckb-vm"}},c={},r=[{value:"Cell",id:"cell",level:2},{value:"Cell Model",id:"cell-model",level:2},{value:"First-Class Assets",id:"first-class-assets",level:2},{value:"Flexible Transaction Fee Coverage",id:"flexible-transaction-fee-coverage",level:2},{value:"Scalability",id:"scalability",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",h2:"h2",hr:"hr",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"Nervos CKB inherits Bitcoin\u2019s architecture and creates the Cell model, a generalized UTXO model as state storage.\nThis approach maintains Bitcoin's simplicity and consistency.\nIn CKB, all states are stored in Cells, computation is done off-chain, and nodes handle all verification."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"cell",children:"Cell"}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.strong,{children:"Cell"})," represents the fundamental data storage unit in Nervos. It can encompass various data types, such as CKBytes, tokens, JavaScript code, or serialized data like JSON strings, offering extensive flexibility in data storage."]}),"\n",(0,n.jsx)("img",{src:"/img/cell/cell-data.png",alt:"Cell Data",width:"688",height:"387"}),"\n",(0,n.jsx)(t.p,{children:"Each cell contains a small program known as a Lock Script that determines the owner of the cell. While typically assigning ownership to a single user, Lock Script can also handle complex operations, such as having multiple owners (multi-sig) or conditional usage within specific timeframes."}),"\n",(0,n.jsxs)(t.p,{children:["A cell may include a ",(0,n.jsx)(t.strong,{children:"Type Script"})," to execute specific rules governing its usage. This empowers developers to customize smart contracts across diverse use-cases, such as issuing Non-Fungible Tokens, limiting the supply of fungible tokens, and implementing custom functionalities to suit unique requirements."]}),"\n",(0,n.jsxs)(t.p,{children:["The collection of cells constitutes the ",(0,n.jsx)(t.strong,{children:"state"})," of CKB. A state verified and held by CKB is any data considered valuable and universally recognized."]}),"\n",(0,n.jsx)("img",{src:"/img/cell/cell-ckb-state.png",alt:"CKB State",width:"688",height:"387"}),"\n",(0,n.jsx)(t.h2,{id:"cell-model",children:"Cell Model"}),"\n",(0,n.jsx)(t.p,{children:"Inspired by Bitcoin's UTXO model, cell model defines the behavior of individual cells within Nervos, as well as the process for updating their contained data."}),"\n",(0,n.jsxs)(t.p,{children:["Cells are immutable. No changes can be made once the cells have been added on-chain. Updating data within a cell requires a process called ",(0,n.jsx)(t.strong,{children:"consumption"}),". This involves consuming the existing cell, extracting and updating the data, followed by creating a new cell with the updated data, which is then added on-chain."]}),"\n",(0,n.jsxs)(t.p,{children:["Each cell can be consumed only once. A non-consumed cell is a ",(0,n.jsx)(t.strong,{children:"live cell"}),". A consumed cell is a ",(0,n.jsx)(t.strong,{children:"dead cell"}),". Once a cell is dead, it can no longer be used."]}),"\n",(0,n.jsx)(t.p,{children:"Transactions reflect the state change of cells, where a group of live cells are consumed and new cells are created. The network validates transactions by executing all associated Lock Scripts and Type Scripts. This ensures adherence to developer-defined rules and prevents fraudulent activities."}),"\n",(0,n.jsx)("img",{src:"/img/cell/cell-lifecycle.png",alt:"Cell lifecycle",width:"688",height:"387"}),"\n",(0,n.jsx)(t.h2,{id:"first-class-assets",children:"First-Class Assets"}),"\n",(0,n.jsx)(t.p,{children:"In cell model, all digital assets (e.g., CKBytes, tokens, collectibles) are considered first-class, exclusively owned by their respective owners. While assets must comply with smart contracts rules during transactions, they are inherently owned by the user, not the smart contracts. This ownership structure ensures that only the owner has permission to use the assets, regardless of how the smart contract defines the token. If a contract exploit, attackers would be unable to access the asset, as it remains under the user's control, effectively mitigating the negative impact."}),"\n",(0,n.jsxs)(t.p,{children:["This ownership structure also defines the responsibility for asset upkeep. As assets occupy space on Nervos, the owner are subject to a small recurring upkeep fee, known as ",(0,n.jsx)(t.strong,{children:"state rent,"})," which is elaborated in the ",(0,n.jsx)(t.a,{href:"https://github.com/linnnsss/docs.nervos.org/blob/concepts-v2/website/docs/concepts/economics.md",children:"Tokenomics"})," section."]}),"\n",(0,n.jsx)(t.h2,{id:"flexible-transaction-fee-coverage",children:"Flexible Transaction Fee Coverage"}),"\n",(0,n.jsx)(t.p,{children:"When transferring tokens, typically, those who initiate the transaction or execute smart contracts must cover the transaction fees. This poses a usability challenge in adoption."}),"\n",(0,n.jsx)(t.p,{children:"Cell model provides the flexibility by allowing any party to cover the transaction fees, eliminating the need for the sender to possess CKBytes (transaction fee in Nervos). Instead, either the receiver or a third-party can cover the fee, significantly enhancing user experience."}),"\n",(0,n.jsx)(t.h2,{id:"scalability",children:"Scalability"}),"\n",(0,n.jsx)(t.p,{children:"Cell model\u2019s unique structure inherently grants scalability, reflected in the three perspectives below."}),"\n",(0,n.jsx)("img",{src:"/img/cell/cell-scalability.png",alt:"Cell model's scalability",width:"688",height:"387"}),"\n",(0,n.jsx)(t.p,{children:"Cell model separates computation and validation for smart contract execution. Computation happens off-chain, where new data is generated. This data is subsequently sent to the network to undergo on-chain validation. Full nodes execute the validation to ensures compliance with developer-set rules."}),"\n",(0,n.jsx)(t.p,{children:"In cell model, smart contract execution is parallel. Each transaction runs independently in its own virtual machine; multiple virtual machines run simultaneously. This gives the cell model dramatic scaling improvements on modern computers with increasing CPU cores."}),"\n",(0,n.jsx)(t.p,{children:"Transactions are highly flexible and effective in cell model. Multiple smart contract operations can be batched into a single transaction, thereby minimizing transactions overhead and processing fees."}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsxs)(t.p,{children:["For more details and the rationale behind the cell model, refer to ",(0,n.jsx)(t.a,{href:"https://medium.com/nervosnetwork/https-medium-com-nervosnetwork-cell-model-7323fca57571",children:"this post"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var n=s(6540);const i={},l=n.createContext(i);function a(e){const t=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(l.Provider,{value:t},e.children)}}}]);